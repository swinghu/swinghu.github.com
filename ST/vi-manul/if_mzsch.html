<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>VIM: if_mzsch</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>IF_MZSCH</h2>
<pre>
<b class="vimtag">*<a name="if_mzsch.txt">if_mzsch.txt</a>*</b>  For Vim version 7.0.  最近更新: 2006年4月


                  <code class="vim">VIM 参考手册    by Bram Moolenaar</code>
                                <code class="vim">译者</code>: Willis
                                http://vimcdoc.sf.net


Vim 的 MzScheme 接口                                    <b class="vimtag">*<a name="mzscheme">mzscheme</a>*</b> <b class="vimtag">*<a name="MzScheme">MzScheme</a>*</b>

1. 命令                                 |<a href="if_mzsch.html#mzscheme-commands">mzscheme-commands</a>|
2. 示例                                 |<a href="if_mzsch.html#mzscheme-examples">mzscheme-examples</a>|
3. 线程                                 |<a href="if_mzsch.html#mzscheme-threads">mzscheme-threads</a>|
4. Vim 访问例程                         |<a href="if_mzsch.html#mzscheme-vim">mzscheme-vim</a>|
5. 动态调入                             |<a href="if_mzsch.html#mzscheme-dynamic">mzscheme-dynamic</a>|

<code class="special">{Vi 无此功能}</code>

只有 Vim 编译时加入 |<a href="various.html#+mzscheme">+mzscheme</a>| 特性后才能使用 MzScheme 接口。

来自于 Brent Fulgham 的工作。
动态调入部分则由 Sergey Khorev 加入。

如何下载 MzScheme 和其它的信息可见:
        http://www.plt-scheme.org/software/mzscheme/

</pre><hr class="doubleline" /><pre>
<h4>1. 命令                                                 <b class="vimtag">*<a name="mzscheme-commands">mzscheme-commands</a>*</b></h4>
                                                        <b class="vimtag">*<a name=":mzscheme">:mzscheme</a>*</b> <b class="vimtag">*<a name=":mz">:mz</a>*</b>
:<code class="special">[range]</code>mz[scheme] <code class="special">{stmt}</code>
                        执行 MzScheme 语句 <code class="special">{stmt}</code>。<code class="special">{Vi 无此功能}</code>

:<code class="special">[range]</code>mz[scheme] &lt;&lt; <code class="special">{endmarker}</code>
<code class="special">{script}</code>
<code class="special">{endmarker}</code>
                        执行内含 MzScheme 脚本 <code class="special">{script}</code>。
                        <code class="note">注意</code>: 如果编译时不带 MzScheme 特性，此命令会失败。要避
                        免错误，见 |<a href="if_perl.html#script-here">script-here</a>|。

                                                        <b class="vimtag">*<a name=":mzfile">:mzfile</a>*</b> <b class="vimtag">*<a name=":mzf">:mzf</a>*</b>
:<code class="special">[range]</code>mzf[ile] <code class="special">{file}</code> 执行 <code class="special">{file}</code> 文件里的 MzScheme 脚本。<code class="special">{Vi 无此功能}</code>
                        所有语句都在 :mzfile 启动时所在的当前缓冲区的命名空间
                        里执行。如果想访问其它命名空间，用 'parameterize'。

这些命令基本上做同样的一件事 - 执行一段 MzScheme 代码。执行期间，"当前行范围"
设为给定的行范围。

:mzscheme 执行的代码来自命令行。
:mzfile 执行的代码来自给定文件的内容。

每个缓冲区都有自己的 MzScheme 命名空间。'vimext' 模块的 `global-namespace' 值
可以绑定全局命名空间。
MzScheme 接口定义从 exn 派生的 exn:vim 例外。若干 Vim 错误抛出此例外。

编译时，MzScheme 接口记住当前的 MzScheme collection 路径。如果你想指定额外的路
径，使用 'current-library-collection-paths' 参数，例如，要附加 (cons) 用户的局
部 MzScheme collection 路径:
<code class="example">    :mz &lt;&lt; EOF</code>
<code class="example">    (current-library-collection-paths</code>
<code class="example">        (cons</code>
<code class="example">            (build-path (find-system-path 'addon-dir) (version) "collects")</code>
<code class="example">            (current-library-collection-paths)))</code>
<code class="example">    EOF</code>


vimext 模块提供所有的功能。

exn:vim 无需显式导入 (import)。

为了避免和 MzScheme 冲突，require 模块时考虑使用 prefix。
例如:
<code class="example">        :mzscheme (require (prefix vim- vimext))</code>

下面的例子都使用此命名方案。<code class="note">注意</code> 你需要为每个缓冲区都这样做一遍。

自动实例化可以用自动命令完成。例如，在 .vimrc 里可以写 (EOF 不应缩进):
<code class="example">    function s:MzRequire()</code>
<code class="example">        if has("mzscheme")</code>
<code class="example">            :mz &lt;&lt; EOF</code>
<code class="example">            (require (prefix vim- vimext))</code>
<code class="example">            (let ((buf (vim-get-buff-by-name (vim-eval "expand(\"<code class="special">&lt;afile&gt;</code>\")"))))</code>
<code class="example">              (when (and buf (not (eq? buf (vim-curr-buff))))</code>
<code class="example">                (parameterize ((current-namespace (vim-get-buff-namespace buf)))</code>
<code class="example">                  (namespace-attach-module vim-global-namespace 'vimext)</code>
<code class="example">                  (namespace-require '(prefix vim vimext)))))</code>
<code class="example">    EOF</code>
<code class="example">        endif</code>
<code class="example">    endfunction</code>
<code class="example"></code>
<code class="example">    function s:MzStartup()</code>
<code class="example">        if has("mzscheme")</code>
<code class="example">            au BufNew,BufNewFile,BufAdd,BufReadPre * :call s:MzRequire()</code>
<code class="example">            :mz &lt;&lt; EOF</code>
<code class="example">            (current-library-collection-paths</code>
<code class="example">                (cons</code>
<code class="example">                    (build-path (find-system-path 'addon-dir) (version) "collects")</code>
<code class="example">                    (current-library-collection-paths)))</code>
<code class="example">    EOF</code>
<code class="example">        endif</code>
<code class="example">    endfunction</code>
<code class="example"></code>
<code class="example">    call s:MzStartup()</code>


全局命名空间此时就会用前缀 "vimext:" 实例化该模块。
                                                        <b class="vimtag">*<a name="mzscheme-sandbox">mzscheme-sandbox</a>*</b>
在沙盘 |<a href="eval.html#sandbox">sandbox</a>| 里执行时，对一些文件系统和 Vim 接口的过程的访问受到限制。

</pre><hr class="doubleline" /><pre>
<h4>2. 示例                                                 <b class="vimtag">*<a name="mzscheme-examples">mzscheme-examples</a>*</b></h4>
<code class="example">        :mzscheme (display "Hello")</code>
<code class="example">        :mzscheme (vim-set-buff-line 10 "This is line #10")</code>

内含脚本的使用:
<code class="example">        function! <code class="special">&lt;SID&gt;</code>SetFirstLine()</code>
<code class="example">            :mz &lt;&lt; EOF</code>
<code class="example">            (display "!!!")</code>
<code class="example">            (vim-set-buff-line 1 "This is line #1")</code>
<code class="example">            (vim-beep)</code>
<code class="example">            EOF</code>
<code class="example">        endfunction</code>
<code class="example"></code>
<code class="example">        nmap <code class="special">&lt;F9&gt;</code> :call <code class="special">&lt;SID&gt;</code>SetFirstLine() <code class="special">&lt;CR&gt;</code></code>

文件执行:
<code class="example">        :mzfile supascript.scm</code>

在另一个缓冲区里用 |<a href="if_mzsch.html#:mzfile">:mzfile</a>| 执行的脚本运行的 MzScheme 程序访问当前缓冲区的
命名空间:
<code class="example">        ; 移到下面的窗口</code>
<code class="example">        (vim-command "wincmd j")</code>
<code class="example">        ; 在窗口所属的缓冲区的上下文内执行，假设该缓冲区定义了 'textstring'</code>
<code class="example">        (parameterize ((current-namespace</code>
<code class="example">                        (vim-get-buff-namespace (vim-curr-buff))))</code>
<code class="example">         (eval '(vim-set-buff-line 1 textstring)))</code>


</pre><hr class="doubleline" /><pre>
<h4>3. 线程                                                 <b class="vimtag">*<a name="mzscheme-threads">mzscheme-threads</a>*</b></h4>
MzScheme 接口支持线程。它们和操作系统的线程相互独立，因此调度是必要的。
'mzquantum' 选项决定 Vim 应每隔多久轮询可用的 MzScheme 线程。
<code class="note">备注</code>
Vim 控制台版本的线程调度不如 GUI 版本的可靠。

</pre><hr class="doubleline" /><pre>
<h4>5. VIM 函数                                             <b class="vimtag">*<a name="mzscheme-vim">mzscheme-vim</a>*</b></h4>
                                                        <b class="vimtag">*<a name="mzscheme-vimext">mzscheme-vimext</a>*</b>
'vimext' 模块提供对 MzScheme 接口定义的例程的访问。

通用
</pre><hr class="singleline" /><pre>
    (command <code class="special">{command-string}</code>)      执行 Vim ":Ex" 风格的命令。
    (eval <code class="special">{expr-string}</code>)            计算 vim 表达式，返回字符串。
                                    |<a href="eval.html#List">List</a>| 通过连接项目并插入换行符来转化为字
                                    符串。
                                    <code class="note">注意</code> 这和 MzScheme 的 eval 有冲突。
    (range-start)                   Scheme 命令传递的行范围的开始行
    (range-end)                     和结束行。
    (beep)                          响铃
    (get-option <code class="special">{option-name}</code> [buffer-or-window]) 得到 Vim 选项值 (局部或全局
                                    值，见 set-option)。
    (set-option <code class="special">{string}</code> [buffer-or-window])
                                    设置 Vim 选项。字符串 <code class="special">{string}</code> 使用设置选
                                    项形式 (optname=optval 或 optname+=optval
                                    等)。如果带 <code class="special">{buffer}</code> 或 <code class="special">{window}</code>，设置局部
                                    选项。<code class="special">{buffer-or-window}</code> 也可以使用符号
                                    'global，这时就会使用 |<a href="options.html#:setglobal">:setglobal</a>|。
    global-namespace                MzScheme 主命名空间。

缓冲区                                                   <b class="vimtag">*<a name="mzscheme-buffer">mzscheme-buffer</a>*</b>
</pre><hr class="singleline" /><pre>
    (buff? <code class="special">{object}</code>)                对象是缓冲区么?
    (buff-valid? <code class="special">{object}</code>)          对象是合法的缓冲区 (也就是，对应真正 Vim
                                    缓冲区) 么？
    (get-buff-line <code class="special">{linenr}</code> [buffer])
                                    得到缓冲区的行。
    (set-buff-line <code class="special">{linenr}</code> <code class="special">{string}</code> [buffer])
                                    设置缓冲区的行。如果 <code class="special">{string}</code> 是 #f，删除
                                    得到的行。[buffer] 参数可选。如果省略，使
                                    用当前缓冲区。
    (get-buff-line-list <code class="special">{start}</code> <code class="special">{end}</code> [buffer])
                                    得到缓冲区的行列表。<code class="special">{Start}</code> 和 <code class="special">{end}</code> 从 1
                                    开始。包含 <code class="special">{Start}</code>，不包含 <code class="special">{end}</code>。
    (set-buff-line-list <code class="special">{start}</code> <code class="special">{end}</code> <code class="special">{string-list}</code> [buffer])
                                    设置缓冲区的行列表。如果字符串列表
                                    <code class="special">{string-list}</code> 是 #f 或 null，删除所有行。
                                    如果列表短于 <code class="special">{end}</code>-<code class="special">{start}</code>，删除其余行。
    (get-buff-name [buffer])        得到缓冲区的文本名。
    (get-buff-num [buffer])         得到缓冲区的编号。
    (get-buff-size [buffer])        得到缓冲区的行数。
    (insert-buff-line-list <code class="special">{linenr}</code> <code class="special">{string/string-list}</code> [buffer])
                                    在缓冲区第 <code class="special">{linenr}</code> 行之后插入行列表。如果
                                    <code class="special">{linenr}</code> 为 0，在缓冲区开头插入。
    (curr-buff)                     得到当前缓冲区。使用 `vimcmd' 模块的例程修
                                    改当前缓冲区。
    (buff-count)                    得到编辑器的缓冲区总数。
    (get-next-buff [buffer])        得到下一个缓冲区。
    (get-prev-buff [buffer])        得到前一个缓冲区。如果没有更多缓冲区，返回
                                    #f。
    (open-buff <code class="special">{filename}</code>)          打开新缓冲区 (编辑文件 "name")。
    (get-buff-by-name <code class="special">{buffername}</code>) 根据文件名得到缓冲区，如果没有此缓冲区，返
                                    回 #f。
    (get-buff-by-num <code class="special">{buffernum}</code>)   根据缓冲区号得到缓冲区 (如果没有对应此编号
                                    的缓冲区，返回 #f)。
    (get-buff-namespace [buffer])   得到缓冲区的命名空间。

窗口                                                        <b class="vimtag">*<a name="mzscheme-window">mzscheme-window</a>*</b>
</pre><hr class="singleline" /><pre>
    (win? <code class="special">{object}</code>)                 对象是窗口么?
    (win-valid? <code class="special">{object}</code>)           对象是合法的窗口 (也就是，对应真正 Vim 窗
                                    口) 么？
    (curr-win)                      得到当前窗口。
    (win-count)                     得到窗口总数。
    (get-win-num [window])          得到窗口的编号。
    (get-win-by-num <code class="special">{windownum}</code>)    根据窗口号得到窗口。
    (get-win-buffer [window])       得到给定窗口的缓冲区。
    (get-win-height [window])
    (set-win-height <code class="special">{height}</code> [window])  取得/设置 窗口高度。
    (get-win-width [window])
    (set-win-width <code class="special">{width}</code> [window])取得/设置 窗口宽度。
    (get-win-list [buffer])         得到对应特定缓冲区的窗口列表。
    (get-cursor [window])           得到窗口的光标位置，以组对 (行号 . 列号)
                                    形式出现。
    (set-cursor (line . col) [window])  设置光标位置。

</pre><hr class="doubleline" /><pre>
<h4>5. 动态调入                                             <b class="vimtag">*<a name="mzscheme-dynamic">mzscheme-dynamic</a>*</b></h4>
MS-Windows 上，可以动态调入 MzScheme 库。|<a href="various.html#:version">:version</a>| 输出这时应包括
|<a href="various.html#+mzscheme%2Fdyn">+mzscheme/dyn</a>|。

这意味着 Vim 只有在必要时才寻找 MzScheme DLL 文件。如果不使用 MzScheme 接口，
你就不需要它们。这样，即使没有这些 DLL 文件，你也可使用 Vim。

要使用 MzScheme 接口，MzScheme DLL 必须在搜索路径上。控制台窗口里输入 "path"
可以看到 (搜索路径) 当前使用的目录。

DLL 的名字必须匹配 Vim 编译时所使用的 MzScheme 版本。对于 MzScheme 209 版本，
它们的名字分别为 "libmzsch209_000.dll" 和 "libmzgc209_000.dll"。要确信这一点，
编辑 "gvim.exe" 文件并查找 ""libmzsch\d\d\d_\d\d\d\.dll\c"。

</pre><hr class="doubleline" /><pre>
<h4>  vim:tw=78:ts=8:sts=4:ft=help:norl:</h4></pre>
<p><i>Generated by vim2html on 2006年 06月 24日 星期六 00:27:59 UTC</i></p>
</body>
</html>
